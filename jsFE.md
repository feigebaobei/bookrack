# no.1

1. 结合律  
2. 交换律  
3. 同一律  
4. 分配律  

# no.2

函数是“一等公民”  
变量是指定函数所在的内存的。  
函数只是输入到输出的映射而已。  


# no.3 纯函数

纯函数可以自给自足。  
能写成纯函数的都写成纯函数。  
可移植性、自文档化  
可测试性  
合理性  
并行代码  

# no.4 curry

柯里化：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。
是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。  
每传递一个参数调用函数后，就返回一个新函数处理剩余的参数。这就是一个输入对应一个输出。哪怕输出是另一个函数，它也是纯函数。  

# no.5代码组合（compose）

    // define
    var compose = (...args) => x => args.reduceRight((v, curfn) => curfn(v), x)
    // usage
    var f = compose(f1, f2, f3)
    f(param)

pointfree // 不必说明参数。  
在compose里不能说明形参，也不影响使用。  

### 范畴学

以下这些组件的搜集就构成一个范畴。  

#### 对象的搜集

通常把数据 类型视作所有可能的值的一个集合。如`Boolean`就可以看作是`[true, false]`

#### 态射的搜集

态射是标准的、普通的纯函数。

#### 态射的组合

就是把一些纯函数组合在一起。

#### identity这个独特的态射

### 总结

组合高于其他所有设计原则，它可使用代码更简单更可读。

范畴学将在应用架构、模拟副作用和保证正确性方面扮演重要角色。

# no.6

声明式代码：不再关心计算机如何工作，而是指出希望得到的结果。
它指明的是做什么，不是怎么做。  

# no.7

Hindley-Milner  
类型签名  
`// head :: [a] -> a`  

# no.8
# no.9
# no.10
